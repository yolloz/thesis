\chapter{Problem Analysis And Solution}

In this chapter, we will discuss the decisions we made during application design and reasons behind every choice. We will define what influenced the chosen application structure. Finally, we will explain the purpose of each part of the application.

%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section{Main Features}
At the beginning of the design we decided to establish three main features that would help us create a successful application. Each of them should give us an advantage over current or future competition as well as reduce the amount of work needed compared to establishing them in the later parts of design and development.

%%-----------------------------------------------------------------------------------------
\subsection{Multi-platform Application}

First step on the way to create any piece of software is to select target platform. There are three main platforms, Microsoft's Windows leading the market share with a big margin to Apple's OS X then followed by Linux (see Fig. \ref{fig01:osMarketShareChart}).

\begin{figure}[h]\centering
\includegraphics[width=1.0\textwidth]{img/StatCounter-os_combined-ww-monthly-201711-201811}
\caption{Desktop Operating System Market Share Worldwide from Nov 2017 - Nov 2018~\citep{osMarketShare}}
\label{fig01:osMarketShareChart}
\end{figure}

For simplicity we could assume that vast majority of users use Windows and we could target this single platform without losing many potential users. But we don't know the exact market share in our target group and focusing on single platform may be a big mistake.
\par
Another reason to support multiple platforms is the recent progress of miniature PCs. The most important task of our application is to play music and these computers have enough computing power to do that and require just a small initial investment into hardware that would do so. These PCs usually run or at least support modified versions of Linux, which has the smallest market share among major operating systems.
\par
The downside to this is the obvious extra amount of work that needs to be done both during analysis and subsequent implementation. However, we consider the benefits of adopting this feature early to be significant enough compared to the risk of having to support additional platform after the implementation is finished.
%%-----------------------------------------------------------------------------------------
\subsection{Modular Design}

If we could divide our application into reasonable amount of modules and define exact interface and relationship among them, the resulting design would have a lot of flexibility both from user's and developer's point of view.
\par
As developers, we would be able to make best decisions regarding each module without having to worry about other modules as long as we keep the predefined interface. We can create specialized versions of one module without having to modify any other. Furthermore, no two modules have to run on the same machine, in the same building or even the same country.
\par
Instead of having one monolithic application, our users may select suitable modules for their needs and customize it to their needs. Every use case has its specifics and adopting this feature allows us to offer each user a suitable solution.
\par
Being bound by predefined interfaces is a drawback that we must face, so they must be designed with extra care and robustness in order to be beneficial.
%%-----------------------------------------------------------------------------------------
\subsection{Scalability}

The last fundamental feature is scalability. We have set a goal to attract a wide range of users, so our application must be able to function properly with any size of music library and any number of regular users wanting to listen to their favourite song. Having adopted modular design earlier, we can achieve scalability also by offering a more capable module as a replacement for one that has reached its maximum potential. Nevertheless, all modules should only be limited by computing power provided by the user.

%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section{Programming Language}

Next decision we had to take was to select a suitable programming language. We had to satisfy the main features and their demands that we have set earlier. That is, we had to find a way to support multiple platforms, while in the same time we needed flexible enough language to handle our modular design and fast enough to help us with scalability.
\par
One solution would be to create an implementation for every platform in a language that is native for them. That would probably result in use of C++ and a Linux-friendly UI framework on Linux, Objective-C on macOS and C\# on Windows. While this would allow us to create suitable application for each platform and to use platform-specific frameworks and libraries, it would be highly labour-intensive as it would require every piece of code to be written three times. Furthermore, it would require knowledge of all three programming languages. Therefore we declined this solution because it offered too little benefits at too high price.
\par
Another way would be to use a language that was designed to be multi-platform like Java. We would only need to write code once and then run it on all three platforms. We had to reject this solution for two reasons. First is the core problem of Java - it requires a Java Virtual Machine to run any Java code, which might be a big penalty in our goal to make our application available on miniature PCs. Second reason is the struggle with UI frameworks that Java offers. While they might have improved over the past few years and might be suitable for business applications, we want to create an application with attractive and modern UI and we do not think Java can offer this. Another language with such capabilities would be C++, but we have to reject it for the same UI framework issues.  
\par
We could try to improve the above solutions. What we needed to realize is that the major problem on each platform was the user interface. That is the major thing that disallows us to use one language across all platforms. With that in mind we can create a solution where the backend - the logic of the application and IO management - would be written in C++ and we would use bindings that Objective-C and C\# offer to call code written in C++. Then we would only need to implement the UI for each platform. This way the amount of code, that would need to be written multiple times, would be significantly reduced. However, we would still need to know all three languages in order to do so.
\par
What we wanted to achieve is to write every piece of code just once. Here we applied my knowledge gained while working on my semestral project. There the whole UI was written in HTML5 and JavaScript. These two technologies are used all around the Internet and web apps have seen a great rise in popularity. It benefits us because it means that there are numerous good frameworks available and users would be used to an application designed in a similar manner. Then we would need to write the UI just once and it would look the same across all platforms.
\par
It turns out that the above-mentioned ideas are now feasible. There is an open-source project written in C++ called Chromium Embedded Framework~(CEF). CEF focuses on facilitating embedded browser use cases in third-party applications~\citep{cef}. That means that we can embed a web browser in our application where we run the UI and the rest of the backend will run alongside that. CEF offers a way to call C++ code from JavaScript so we do not need to worry about communication between these two languages.
%\todo{write a paragraph about previous project on electron and that we found CEF and that identical UI benefits us}

%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section{Modules}

In this section we will talk about all the modules that we decided to divide our application into. We will explain why we need each module, what is their role and purpose and how they communicate between each other.
\par
First, we need to understand what functionality our application requires. Then we can group similar functionality together and wrap it up in modules. Each module should be able to perform its task without the help of another and offer certain services to other modules or be able to consume other module's services if needed. These services will then be predefined by a certain interface so we gain an ability to work with different implementations of on module without the need to modify other modules.
\par
We need to have access to a collection of music files, keep information about their location, store their metadata like title, artist, album for easier browsing and allow to group them into playlists. Usually, this is called music library.
\par
Then we need to be able to play these music files. In order to do that, first we need to access them. Most music files are encoded to use less storage space, so we need to decode them. Only then we can send the data to sound card to finally play some music.
\par
We will also need to allow our users to browse the music library. Let them order the songs and create their playlists. Give them control over music playback. Allow them to customize the application and set the settings they need. Show them what regular users ordered to be played. We require our UI to support all of this.
\par
Lastly, we need a tool for synchronization between our application and the regular users. They want to see what songs we offer in our playlist and we want to know their orders so we can play what they desire.
\par
Above-mentioned enumeration of functionality roughly describes requirements for each module. Since there are much more details about each of them, we will define the requirements and interface for each module below. For information about implementation of modules, see \todo{add link to implementation chapter}

%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section{Fileserver Module}

Fileserver module manages music files contained in music library. It knows the location of these files and how to access them, allows adding or removing files and distributes them on demand for playback.
\par
Fileserver handles extraction of metadata from music files. Supported metadata are song title, artist name, album name, genre name and song duration. These are stored for easier browsing of the library.
\par
This module allows to browse, search and order songs in its music library. Additionally, these songs can then be grouped in playlists. A playlist is a collection of songs from music library. It has a name and optionally a description. Every user can see only their playlists.
\par
Services provided by this module are available through a predefined interface and it does not use or require any other module.

%%-----------------------------------------------------------------------------------------
\subsection{Interface}

This interface defines how to access and browse music library offered by fileserver. We decided to support only browsing the library and managing playlists and omit manipulation with music files from this interface, as the way of working with files may differ greatly across platforms and it might also be unwanted to offer file management capability to users. Instead, implementations of this module are free to choose their own way of managing the contents of the library.
\par
First, we need to choose a suitable interface technology. We need to support distributed architecture, so we have to choose from network technologies.
\par
One option would be to communicate with fileserver over a dedicated socket. However, we declined this option, because we do not need to have an open connection with fileserver at all times so it would be a waste of resources. It would limit the number of possible connections to a fileserver and therefore the solution would not be scalable enough.
\par
Another option is to create this interface as web API or web service \todo{napisat poznamku pod ciarou co ktora vec znamena}. This approach seems more suitable for the task as the main purpose of fileserver's interface is to provide access to data. While the same result can be achieved using either technology, we opted for RESTful API instead of SOAP-based web service, because it is more modern, it is easier to implement and it uses HTTP protocol in a more straight-forward way, so the resulting implementations can be more lightweight.
\par
The resulting interface follows principles of REST API design. All requests are stateless, no state needs to be stored by the interface implementation. Each resource is defined by the link that it can be accessed by and query parameters are used to modify the result. HTTP request method determines the action performed when accessing a resource. GET method is used to retrieve resources, POST method is used to create new resource, PUT requests modify resources and DELETE method removes resources. JSON file format is used for transferring data. For more details see the interface documentation \todo{add link to documentation}.

%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section {Player Module}

Player module, as its name suggests, takes care of playing music and all related tasks, such as decoding and playback control. Since music files do not have to be located on the machine where this module is running, it has to take care of getting and caching necessary music files.
\par
This module utilizes fileserver module to get music files and offers a communication channel to control its behavior.

%%-----------------------------------------------------------------------------------------
\subsection{Communication and Control}

The communication with player module is different from fileserver module. Fileserver is stateless, can support multiple users and communication is mostly one-way. On the other hand, player needs to preserve its state, e.g. playback progress or cache, it can only support one user as there is usually only one audio device available and it needs to communicate both ways, besides reacting to actions it can also trigger action on its own. Therefore the requirements for communication technology are different too.
\par
Due to the properties mentioned above, we cannot use web service approach. However, using a dedicated socket seems to be very suitable. Upon establishing a connection, player may stop listening for new connections, so no more than one session can be running at a time. The state can be easily held within a session since there are only two participants. Two-way communication can be achieved simply by choosing an appropriate protocol.
\par
What we try to accomplish is to communicate with and control the player as if it was a part of our code, but it can be located anywhere accessible via network. This technique is called Remote~Procedure~Call~(RPC)\todo{poznamka pod ciarou}. Using this technique, we can call player function stubs as if it was a local component. These stubs then pack function name with parameters into a message and send it to a remote player instead of calling the actual function locally. Upon receiving the message, the player unpacks the message and calls the desired function with provided parameters.
\par
The last decision we have to take is the protocol that we use to transfer RPC messages. As mentioned above, full-duplex communication is desired. Furthermore, we know that the player will communicate with manager module, which uses web technologies. We consider C++ to be more capable to adapt than web technologies, web-friendly protocol would therefore be beneficial as it would simplify the implementation of manager module without making player implementation too complicated.
\par
We decided to use WebSocket protocol to transfer PRC messages encoded in JSON. WebSocket is a common protocol used by web applications that require a full-duplex communication and has implementations available in many programming languages including C++, so it does not limit different player module implementations. JSON is a standard simple format for transferring messages between different systems. Encoding RPC messages in JSON is easy to use and platform or language independent.
\par
For the detailed documentation of communication see \todo{link to documentation}

%%-----------------------------------------------------------------------------------------
\subsection{Caching, Queues and Playback}

The application is expected to provide continuous music playback. The distributed module design creates a need to allow music file caching, so that next song is always ready to play without a pause for buffering after the previous one finished. To achieve that, player module needs to know which songs to cache in advance. To solve that, it could have an internal queue where the songs would be enqueued by an outside source when there is a lack of them and player would dequeue and cache them when needed.
\par
There is one problem with a single queue solution. One of the application's main features is the song ordering system for regular users. It means that we should play ordered songs when there are any available and play any other songs when there are no orders. However, putting all songs in a single queue does not provide enough flexibility to do that. Instead, we use two separate queues. First, called order queue, is used for ordered songs. The other is called playlist queue and is used for random songs that are played when order queue is empty or buffering. Another difference between them is that order queue is filled by an outside source when an order is made while playlist queue is filled by the same outside source, but on request by player module itself when there are not enough songs in this queue. Furthermore, this design allows each implementation to determine its own required queue sizes and caching algorithm.
\par
The two queue design introduces necessary flexibility for song caching. On the other hand, it is simple to determine which song is next using only one queue, but there are two choices with two of them. It is therefore important to establish a common behavior across all implementations. The following algorithm is required to be followed. It can be described by two ideas - ordered songs have preference to playlist songs and random song is better than awkward silence.

\begin{itemize}
    \item If order queue is not empty, check if first item is already cached. If yes, this is the next song. If not, make sure it is buffering and continue to next step.
    \item If playlist queue is not empty, check if the first item is already cached. If yes, this is the next song. If not, make sure it is buffering, wait a short amount of time and repeat this algorithm again.
    \item If both queues are empty, report an error
\end{itemize}

This algorithm ensures that ordered songs are played whenever it is possible, but if they were ordered too recently to be buffered, a random song is played instead. To provide maximal reliability, enough random songs should be cached even when there are any orders.

%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section {Realtime Database Module}

So far we discussed how to store and play music from our application and what variety of functions it can offer to its user, but we did not mention how to share the library and application state with other users and let them make the song orders. The role of this module therefore is to be place where the information is exchanged. It is the middle ground, where desktop application users upload metadata from their current music library or playlist and read song orders and regular mobile application users can access and browse the data to make their orders.

%%-----------------------------------------------------------------------------------------
\subsection{Database Choice}

The nature of the module's role is to store some data, so it is a sort of database. Currently there are several different types of databases available on the market. To choose the right solution, first we need to take a closer look at what data we want and need to store there and how we would like to deal with it. Then we can evaluate pros and cons of each database solution in regard to our specific needs.

%%-----------------------------------------------------------------------------------------
\subsubsection{Stored Data}

As we mentioned before, the most important data we want to keep are the song library metadata. These are stored on the fileserver but we want to store a simplified version online to allow regular users to browse it. The actual size of a music library may range from a few hundreds to thousands or even tens of thousands of songs while only a small part of that might be available in current playlist. Data redundancy and synchronization are the main issues that need to be addressed. We can keep the entire music library stored online, synchronizing it with fileserver after every change. Data transfers would be numerous yet relatively small, but space requirements would be big. On the other hand, we can store online only the current playlist. No storage space would be occupied when the application is offline as well as no data for currently unavailable songs would need be stored. Space requirement reduction would cost the users the added time that it would take to upload the entire new playlist on change. The number of data transfers would decrease, but their size would grow greatly.
\par
The next purpose of this module existence is to store orders of regular users. Once they find their desired song, we need to store it so the application can prepare to play it, other regular users can check what songs will be played next and also when will their song start playing. Here the main issue is how to synchronize ordered songs between this module and the application. One way is to let application periodically check for new orders. This would generate a number of useless requests that would need to be handled. The other way is to notify the application after an order was made, but that is a lot more difficult to implement.
\par
The last data we need to store are user data. Application users are identified as an establishment or a music spot where the given music is played. We need to provide that information to regular users. Regular users also need an account and these data need to be stored somewhere. There are multiple reasons for establishing these accounts. It slightly prevents a bad behavior when malicious orders are made by adding extra work to create the account and after this behavior is recognized the account can be banned. As this application is also a jukebox substitution and orders there are paid for, user accounts are good to have to allow this feature in the future. Lastly, having information about users can be used to improve their user experience as mobile application may customize its behavior to suit each user as much as possible. It is important to mention that such data might be sensitive so they should be appropriately protected.

%%-----------------------------------------------------------------------------------------
\subsubsection{Realtime Database}

Taking all mentioned reasons into consideration, we decided to use Firebase Platform~\citep{firebase} and its Firebase Realtime Database as a data storage. Firebase is Google's platform for mobile and web applications and naturally has great support for them. It provides software development kit~(SDK) for all major mobile and web programming languages. Besides realtime database it offers file storage, which might be of use for uploading album and artist artwork, or secure and easy-to-use authentication service that supports multiple sign-in options either with e-mail or using other account on Facebook, Twitter or others. All these useful tools not only help simplify our application, but can be beneficial for the design and development of mobile application for regular users.
\par
The Firebase Realtime Database is a cloud-hosted NoSQL database. Data is stored as JSON and synchronized in realtime to every connected client~\citep{firebaseDocs}. It allows to create a subscription on any node in the JSON's tree and it notifies all subscribers about any changes on that node. This particular feature is useful for song orders. After the application's user publishes the playlist, the application can subscribe to its orders node in database and it will be notified every time a new order is made.
\par
One of the basic advantages of NoSQL database is its data structure flexibility. We can utilize it for our user data. This data is likely to be modified with new features, whether it is data collection or user settings. It would not be important to change the database structure after every added feature, only accounts that utilize the new feature would need to be modified.
\par
The trade-off of this solution is song library metadata. Putting it in NoSQL database means we strip it off important indices that would help the regular users to search in library. Their searches would be more performance-demanding. There are two ways to deal with this: either design the mobile application in a smart way to reduce the amount of searches that the regular users make or use a standalone SQL database just for this data if it proves to be worth the effort. On the other hand, without indices it is much easier to add and remove the data to the database, so bulk-uploading current playlist on the server would be easier. We are satisfied with this trade-off, as it is much easier to maintain just one database and if it proves important, it is still possible to switch to two database solution.
%%-----------------------------------------------------------------------------------------
%% SECTION
%%-----------------------------------------------------------------------------------------
\section {Manager Module}

The last module is the one that puts the pieces of the puzzle together. It consumes services provided by all other modules, manages the communication and whole application run and it provides graphical user interface. 
\par
At the beginning of the chapter we chose JavaScript as the programming language for the GUI implementation in this thesis. However, thanks to modular design it is possible to create an implementation of this module in any other suitable programming language. While creating another implementation for personal computers might be considered controversial with our philosophy of reducing the amount of work by creating a cross-platform implementations, it would make sense to create a different implementation of this module for mobile devices like tablets and smartphones because of the obvious differences in input method (mouse and keyboard vs. touch screen) and screen size. Even though such implementation is outside of the scope of this thesis, there are multiple frameworks that allow cross-platform design approach for these devices similar to ours.

%%-----------------------------------------------------------------------------------------
\subsection {Communication With Other Modules}

The Fileserver module exposes API for browsing its music library and playlist modification. This module should consume that API and provide its resources to user via GUI.
\par
The communication with Player module is a little more complicated. In this two-way communication, Manager module sends commands to Player module based on user interaction, fills its song queues and displays Player's state to user. \todo{? either describe communication in more detail here or refer to documentation ?}
\par
Lastly, Realtime Database module is used as authentication authority, Manager module gets user account information and song orders from it and provides it with music library metadata.